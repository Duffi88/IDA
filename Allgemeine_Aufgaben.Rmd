---
title: "Allgemeine Aufgaben"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Allgemeine Aufgaben


## 1.

Um mit mit den Daten in R arbeiten zu können, müssen diese zuerst eingelesen und zusammengefügt werden.
Außerdem muss die Spalte _Wareneingang_ formatiert werden, damit sie im Datumsformat vorliegt.
```{r}
#Laden der nötigen Packages
library(readr)
library(dplyr)
library(ggplot2)

# Einlesen der Datensätze
Logistikverzug_K7 <- read_csv2("Logistikverzug_K7.csv")
Komponente_K7 <- read_csv2("Komponente_K7.csv")

# Join der Datensätze
Logistikverzug <- inner_join(Komponente_K7, Logistikverzug_K7, by = "IDNummer")

# Formatieren der Spalte "Wareneingang" ins Datumsformat
Logistikverzug$Wareneingang <- as.Date(Logistikverzug$Wareneingang, format = "%d.%m.%Y")
```

Um das Verteilungsmodell des Logistikverzuges ermitteln zu können, wird zuerst der Vektor _Verzug_ erstellt, der die Differenzen zwischen Warenausgang (also Produktionsdatum) und Wareneingang enthält. Danach werden die Verteilung des Verzuges visualisiert und Mittelwert und Median ermittelt. Da die Verteilung annähernd symmetrisch um den Mittelwert ist und Mittelwert und Median übereinstimmen, kann von einer Normalverteilung ausgegangen werden.
Um die kürzeste und die längste Zeitspanne zwischen Warenausgang und Wareneingang herauszufinden, werden Minimum und Maximum des _Verzug_-Vektors ermittelt


```{r}
# Erzeugen des Vektors "Verzug"
Verzug <- as.numeric(difftime(Logistikverzug$Wareneingang, Logistikverzug$Produktionsdatum, units = "days"))

# Darstellung der Verteilung
df <- data.frame(Verzug)
ggplot(df, aes(Verzug)) +
  geom_histogram(aes(y = ..density..), binwidth = 0.6) +
  stat_function(fun = dnorm, 
                args = list(mean = mean(df$Verzug), sd = sd(df$Verzug)),
                col = 'blue') +
  geom_vline(xintercept = mean(Verzug), color = "red")

# Mittelwert
mean(Verzug)

# Median
median(Verzug)

# kürzeste Zeitspanne
min(Verzug)

# längste Zeitspanne
max(Verzug)
```

## 2.

Bei gleichen Spaltennamen erhält die Spalte des ersten Datensatzes die Endung ".x", die des zweiten Datensatzes die Endung ".y".

```{r}
names(Logistikverzug)
```

## 3.

Mithilfe des `str`-Befehls kann man sich einen Überblick über den Datensatz verschaffen.
Der Datensatz enthält 306490 Zeilen ("observations") und 11 Spalten ("variables"). Da vier der Spalten doppelt auftreten, beschreibt der Datensatz folglich sieben Merkmale.

```{r}
str(Logistikverzug)
```

## 4.

Um die Effektivität des Joins beurteilen zu können, wird die Anzahl der Zeilen eines der Ausgangsdatensätze (da beide Augangsdatensätze die gleiche Zeilenanzahl haben) mit der Anzahl der Zeilen des gejointen Datensatzes verglichen. Da bei der Anwendung von `inner_join` nur die Zeilen übernommen werden, die in beiden Ausgangsdatensätzen vorkommen, liegt die Effektivität des Joins nur dann bei 100%, wenn der Vergleich ergibt, dass die Zeilenanzahl die selbe ist.

```{r}
# Vergleich der Zeilenanzahl
nrow(Logistikverzug) == nrow(Komponente_K7)

# TRUE, die Effektivität liegt also bei 100 %

```
